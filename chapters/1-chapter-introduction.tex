%======================================================================
\chapter{Introduction} \label{ch:Intro}
%======================================================================
Zero-knowledge succinct non-interactive argument of knowledge (\gls{zksnark}) protocols are cryptographic schemes involving a prover and a verifier. The prover generates a publicly verifiable and succinct proof that demonstrates knowledge of a witness vector (secret inputs) satisfying a given constraint system ($\mathcal{NP}$ statement). The proof does not reveal any information about the witness itself. These protocols have a wide range of applications, such as post-quantum secure digital signature algorithms \cite{faest2023,picnic2017,Preon2023,picnic2018}, privacy-preserving applications over blockchains \cite{zcash-proc,Hawk,ZeeStar,ZEXE,williamson2018aztec}, blockchain scalability solutions using rollups \cite{Arun2024Jolt,Chaliasos2024,Thibault2022,PolygonZKEVM,zkSync,STARKnet}, data availability proofs for lightweight clients in Ethereum \cite{HallAndersen2024FRIDA}, the proof of replication in Filecoin~\cite{benet2017proof}, verifying the computation of neural networks~\cite{Haochen2024zkLLM,Chen2024ZKML,Weng2021Mystique}, and verifying the authenticity of edited images~\cite{Dziembowski2025VIMz}. 
The efficiency of the prover and verifier algorithms, along with the proof size of the  \gls{zksnark} protocol, are crucial factors influencing the cost-effectiveness and overall practicality of the aforementioned applications. Additionally, two other important factors are: first, whether the \gls{zksnark} protocol relies on a trusted setup or employs a transparent setup; and second, whether it offers plausible post-quantum security against a malicious prover with quantum capabilities.

With the increasing adoption of \glspl{zksnark}, optimizing or accelerating the implementation of algorithms within these protocols has become an active and extensively studied research area~\cite{ECFFT1_2023,ECFFT_2022,Diamond2023Towers,CHES:LuoFuGong23,Ji2024GPU,Jandhyala2024AirFRI}. Fast Fourier transform (\gls{fft}) algorithms are central to the performance of \gls{zksnark} constructions, as both post-quantum vulnerable~\cite{Groth2016,Marlin2020,Bulletproofs2018,Gabizon2019PLONK,halo2-book} and post-quantum secure~\cite{Ames2017Ligero,Ben-Sasson2018STARK,Aurora2019,Chiesa2020Fractal,Polaris} variants depend on polynomial commitment schemes. These commitments are applied to polynomials interpolated from the secret and public values in the constraint system.

The \gls{fft} algorithm used in a \gls{zksnark} protocol can be either multiplicative~\cite{CooleyTukeyFFT1965,Rader1968FFT,Bluestein1970FFT} or additive~\cite{Cantor1989FFT,zurGathenFFT,Gao2010FFT,LCH-conv2016}, depending on the structure of the polynomial evaluation domains. These domains are typically either multiplicative cosets in a prime field or additive cosets (affine subspaces) in a binary extension field. The choice of domain is influenced by the underlying polynomial commitment scheme employed in the protocol, which determines whether the values in the constraint system (i.e., polynomial evaluations) lie in a prime field or a binary extension field. For instance, \glspl{zksnark} based on pairing-based polynomial commitments (e.g.,\cite{KZG2010}) and inner-product argument schemes (e.g.,\cite{Bulletproofs2018}) typically operate over prime fields. In contrast, \glspl{zksnark} utilizing Merkle hash tree~\cite{Merkle1980} based commitment schemes (e.g.,~\cite{FRI2018}) can operate over either binary extension fields or prime fields. Merkle hash tree based schemes do not rely on cryptographic hardness assumptions that are vulnerable to quantum attacks, this property makes them attractive for constructing post-quantum secure \glspl{zksnark}~\cite{Ames2017Ligero,Ben-Sasson2018STARK,Aurora2019,Chiesa2020Fractal,Zhang2020Virgo}.

\begin{figure}[h]
	\centering
	{
		\input{Plots/plot_additive_vs_mult_aurora}
	}
	\caption[The Aurora zkSNARK Runtime Over Prime Versus Binary Extension Fields]{Comparison of Aurora \gls{zksnark}~\cite{Aurora2019} performance over prime fields and binary extension fields on an AMD Ryzen 9 9950X @ 5.7 GHz. The prime field is defined by a 255-bit prime $p$, corresponding to the scalar field of the BLS12-381 curve~\cite{BLS_curve2003}. $N$ denotes the number of constraints.}
	\label{fig:prime_vs_binary_aurora}
\end{figure}

Additive \glspl{fft} offer distinct advantages in scenarios where multiplicative \glspl{fft} are constrained. Specifically, multiplicative \glspl{fft} require the evaluation domain of size  $n=2^m$ to contain an $n$-th root of unity, which is not always available. In such cases, \gls{zksnark} protocols over prime fields must resort to slower alternatives, such as the method proposed in~\cite{BOSTAN2005Evaluation}, for polynomial interpolation and evaluation, instead of using efficient \gls{fft}-based techniques. Moreover, finite field arithmetic operations (addition/subtraction, multiplication, squaring, and inversion) tend to be faster, more power-efficient, and more area-efficient in hardware when performed over binary extension fields as compared to prime fields~\cite{Wenger2012PrimevsBinary, Diamond2023Towers}.
Figure \ref{fig:prime_vs_binary_aurora} compares the runtime of the Aurora \gls{zksnark}\cite{Aurora2019} prover algorithm implemented over two different fields: the prime field corresponding to the scalar field of the BLS12-381 curve~\cite{BLS_curve2003}, and the binary extension field $\mathbb{F}_{2^{256}}$, as implemented in libiop~\cite{libiop}. The figure also illustrates the performance gains achieved through the acceleration techniques for additive \gls{fft} algorithms presented in Chapter~\ref{ch:additive-fft}.


While \gls{fft} algorithms play a crucial role in accelerating \glspl{zksnark} and numerous other applications~\cite{Bisheh2021NTT,LCH-Fast_Mult2018,LCH-Frobenius2018,BernsteinChouSchwabe2013,BernsteinChou2014}, the optimization of post-quantum secure \glspl{zksnark} can be pursued through various approaches. The fast Reed-Solomon (\gls{rs}) interactive oracle proof of proximity (\gls{fri}) serves as the foundation for many post-quantum secure \glspl{zksnark}, including~\cite{Ben-Sasson2018STARK,Aurora2019,Chiesa2020Fractal,Polaris}. In addition, the Polaris \gls{zksnark}~\cite{Polaris} leverages the GKR protocol~\cite{GKR2008} to offload certain computations to the prover. Chapter~\ref{ch:polaris} proposes an optimization technique to accelerate the \gls{fri} protocol and introduces an efficient method for instantiating the arithmetic circuit used in Polaris's GKR protocol.


As previously mentioned, \gls{zksnark} protocols are widely used in privacy-preserving applications and typically rely on the rank-1 constraint system (\gls{r1cs}), which is well-suited for representing arithmetic circuits. This structure is particularly advantageous because it allows the prover to generate a zero-knowledge proof (\gls{zkp}) of knowledge of the preimage of a leaf node in a Merkle hash tree~\cite{Merkle1980}, where the tree is computed using the circuit representation of a hash function (e.g., SHA-256). Several applications, such as those presented in~\cite{zcash-proc,Hawk,williamson2018aztec,ZEXE,Steffen2022Zapper}, leverage Merkle hash trees to preserve user privacy.
Chapter~\ref{ch:zupply-design} presents a novel anonymous authentication token (\gls{aat}) framework that supports unlinkable \gls{aat} ownership transfer (\gls{aatot}), including the ability to merge and divide \glspl{aat} in an unlinkable manner. This construction utilizes a Merkle hash tree to store \glspl{aat} and facilitates their transfer over a public blockchain. This approach enables the creation of off-chain, anonymously maintained, decentralized data records organized as a directed acyclic graph (\gls{dag}), with practical applications in supply chain management~(\gls{scm}). 
Chapter~\ref{ch:zupply_implementation} presents the implementation of the proposed framework using two \glspl{zksnark}. The first is the Groth16 \gls{zksnark}~\cite{Groth2016}, which requires a one-time trusted setup and relies on cryptographic assumptions that are vulnerable to quantum attacks. The second is the Aurora \gls{zksnark}\cite{Aurora2019}, which does not require any trusted setup and is plausibly secure against quantum adversaries.

In the remainder of this thesis, Chapter~\ref{ch:preliminaries} provides the definitions and mathematical preliminaries essential to the presented work, Chapter~\ref{ch:lit_review} reviews the literature relevant to this research. The contributions of the thesis are presented in Chapters~\ref{ch:additive-fft},\ref{ch:polaris},\ref{ch:zupply-design}, and~\ref{ch:zupply_implementation}, and are summarized as follows:
\begin{enumerate}
\item Chapter~\ref{ch:additive-fft} presents a comprehensive study and optimization of additive \gls{fft} algorithms, focusing on the Cantor~\cite{Cantor1989FFT} and Gao-Mateer~\cite{Gao2010FFT} methods. In the Cantor algorithm, a novel theoretical analysis of vanishing polynomials is provided, where the number of terms is precisely determined based on Hamming-weight, allowing for accurate estimation of additions, improving upon previously reported upper bounds. The vanishing polynomials and multiplication factors are efficiently computed. Modular building blocks for the Cantor \gls{fft} are proposed and integrated into the Aurora \gls{zksnark}~\cite{libiop}, resulting in significant performance improvements over the Gao-Mateer algorithm. In the Gao-Mateer method, the \textsf{Expand} and \textsf{Aggregate} modules are analyzed, the Cantor special basis is incorporated, and two levels of precomputation are introduced to reduce computational overhead. The \gls{fft}/\gls{ifft} call complexity in Aurora is analyzed, with emphasis on how the choice of shift elements in affine subspaces reduces space complexity in the Cantor \gls{fft}. Optimized \CC implementations of all algorithms and precomputation techniques are provided, and a detailed comparative evaluation is performed.

\item Chapter~\ref{ch:polaris} presents an instantiation of the \gls{fri} protocol, in which field inversion operations are eliminated in both the Commit and Query phases to achieve improved efficiency. Additionally, an instantiation of the GKR circuit tailored to the Polaris implementation is described. The circuit is designed as a satisfiability circuit to enable the verifiable computation of values essential to the Polaris protocol while minimizing the number of gates. This design reduces communication overhead as well as the complexities of the verifier and the prover.

\item  In Chapter~\ref{ch:zupply-design}, a novel \gls{aat} scheme is designed using zero-knowledge proofs (\glspl{zkp}) on smart contract-enabled public blockchains. The proposed framework, Zupply, consists of a set of algorithms and protocols that enable on-chain unlinkable \gls{aat} ownership transfers (\gls{aatot}) and off-chain anonymous data authentication. Four main properties are satisfied: (1) Anonymity is preserved for data uploaders and \gls{aat} owners, except for \glspl{aat} that initiate a \gls{dag}; (2) Unlinkability is ensured by concealing the link between entities collaborating to maintain the \gls{dag} of supply chain data records; (3) Integrity is guaranteed as each data record is authenticated, remains unaltered, and is verifiably created by the authorized entity responsible for that stage; and (4) Trustlessness is achieved by eliminating the need for trusted parties during protocol execution, relying instead on public blockchains for decentralization. In addition, storage is separated from the blockchain while maintaining a concealed link to the \glspl{aat}. This design enables entities to anonymously upload data. The off-chain anonymous authentication mechanism reduces blockchain storage costs, enhances anonymity, and allows entities to choose storage strategies that best align with their decentralization and cost requirements.

\item In Chapter~\ref{ch:zupply_implementation}, Four arithmetic circuits, \textsf{Auth}, \textsf{Trans}, \textsf{Merge}, and \textsf{Div}, are designed and employed in the Zupply framework to express the $\mathcal{NP}$ statements required for \glspl{zkp}. In the first implementation variant of the Zupply framework, Groth16~\cite{Groth2016}, a \gls{zksnark} known for producing succinct proofs and enabling fast verification, is integrated. This protocol is based on bilinear groups and requires a trusted setup to generate the necessary cryptographic parameters. The implementation is evaluated over two elliptic curves: BN254~\cite{BNcurve}, which offers approximately 100-bit security~\cite{Barbulescu2019}, and BLS12-381~\cite{BLS_curve2003}, designed for 128-bit security. In the second implementation variant, Aurora~\cite{Aurora2019} is integrated into the Zupply framework to achieve a transparent setup and plausible post-quantum security against quantum-capable adversarial provers. The computational performance of this variant is compared with the Groth16-based implementation over the BN254 and BLS12-381 curves.

\end{enumerate}
Finally, Chapter~\ref{ch:conclusion} concludes the thesis by summarizing its contributions and outlining directions for future work.

    